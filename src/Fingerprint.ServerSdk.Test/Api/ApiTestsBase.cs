/*
 * Server API
 *
 * Fingerprint (https://fingerprint.com) is a device intelligence platform offering industry-leading accuracy. Fingerprint Server API allows you to search, update, and delete identification events in a server environment. It can be used for data exports, decision-making, and data analysis scenarios. Server API is intended for server-side usage, it's not intended to be used from the client side, whether it's a browser or a mobile device.
 *
 * The version of the OpenAPI document: 4
 * Contact: support@fingerprint.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.Extensions.Hosting;
using Fingerprint.ServerSdk.Client;
using Fingerprint.ServerSdk.Extensions;
using Microsoft.Extensions.DependencyInjection;

namespace Fingerprint.ServerSdk.Test.Api
{
    public class ApiRequest
    {
        public HttpListenerRequest Request;

        public string Body;
    }

    /// <summary>
    ///  Base class for API tests
    /// </summary>
    public class ApiTestsBase : IDisposable
    {
        protected readonly IHost Host;

        private HttpListener _mockServer;
        private WebHeaderCollection _mockResponseHeaders;
        protected int MockResponseStatusCode = (int)HttpStatusCode.OK;
        private byte[] _mockResponseBytes;

        protected const string ServerUrl = "http://127.0.0.1:8081/";

        protected readonly List<ApiRequest> Requests = new List<ApiRequest>();

        protected ApiTestsBase(string[] args)
        {
            Host = CreateHostBuilder(args).Build();
            StartServer();
        }

        private static IHostBuilder CreateHostBuilder(string[] args) => Microsoft.Extensions.Hosting.Host.CreateDefaultBuilder(args)
            .ConfigureApi((context, _, options) =>
            {
                options.BaseUrl = ServerUrl;

                var bearerToken1 = new BearerToken("<token>", timeout: null);
                options.AddTokens(bearerToken1);
            });

        private void StartServer()
        {
            _mockServer = new HttpListener();
            _mockServer.Prefixes.Add(ServerUrl);
            _mockServer.Start();

            _mockResponseHeaders = new WebHeaderCollection();
            MockResponseStatusCode = (int)HttpStatusCode.OK;

            HandleConnection().GetAwaiter();
            Console.WriteLine("Started server");
        }

        protected T GetMockResponse<T>()
        {
            return JsonSerializer.Deserialize<T>(Encoding.UTF8.GetString(_mockResponseBytes), Host.Services.GetService<JsonSerializerOptions>());
        }

        protected void SetupMockResponse(string fileName)
        {
            var path = Path.Combine(AppContext.BaseDirectory, "mocks", fileName);
            var mockResponse = File.ReadAllText(path);
            _mockResponseBytes = Encoding.UTF8.GetBytes(mockResponse);
        }

        private async Task HandleConnection()
        {
            while (_mockServer != null)
            {
                var ctx = await _mockServer.GetContextAsync();

                // Peel out the requests and response objects
                var req = ctx.Request;
                var resp = ctx.Response;

                var body = "";

                if (req.HasEntityBody)
                {
                    using (var reader = new StreamReader(req.InputStream, req.ContentEncoding))
                    {
                        body = await reader.ReadToEndAsync();
                    }
                }

                Requests.Add(new ApiRequest()
                {
                    Request = req,
                    Body = body
                });

                // Print out some info about the request
                Console.WriteLine(req.Url?.ToString());
                Console.WriteLine(req.HttpMethod);
                Console.WriteLine(req.UserHostName);
                Console.WriteLine(req.UserAgent);
                Console.WriteLine();

                resp.StatusCode = MockResponseStatusCode;

                if (_mockResponseHeaders != null)
                {
                    foreach (var key in _mockResponseHeaders.AllKeys)
                    {
                        var value = _mockResponseHeaders[key];

                        if (value != null)
                        {
                            resp.AddHeader(key, value);
                        }
                    }
                }

                if (_mockResponseBytes != null)
                {
                    resp.ContentType = "application/json";
                    resp.ContentEncoding = Encoding.UTF8;
                    resp.ContentLength64 = _mockResponseBytes.LongLength;

                    await resp.OutputStream.WriteAsync(_mockResponseBytes, 0, _mockResponseBytes.Length);
                }

                resp.Close();
            }
        }

        public void Dispose()
        {
            Console.WriteLine("Closing server...");
            Requests.Clear();
            _mockServer?.Close();
            Host?.Dispose();
        }
    }
}