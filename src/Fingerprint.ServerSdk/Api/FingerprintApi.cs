// <auto-generated>
/* 
 * Fingerprint Server API
 *
 * Fingerprint Server API allows you to search, update, and delete identification events in a server environment. It can be used for data exports, decision-making, and data analysis scenarios. Server API is intended for server-side usage, it's not intended to be used from the client side, whether it's a browser or a mobile device. 
 *
 * The version of the OpenAPI document: 4
 * Contact: support@fingerprint.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Fingerprint.ServerSdk.Client;
using Fingerprint.ServerSdk.Model;

namespace Fingerprint.ServerSdk.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IFingerprintApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        FingerprintApiEvents Events { get; }

        /// <summary>
        /// Delete data by visitor ID
        /// </summary>
        /// <remarks>
        /// Request deleting all data associated with the specified visitor ID. This API is useful for compliance with privacy regulations.  ### Which data is deleted? - Browser (or device) properties - Identification requests made from this browser (or device)  #### Browser (or device) properties - Represents the data that Fingerprint collected from this specific browser (or device) and everything inferred and derived from it. - Upon request to delete, this data is deleted asynchronously (typically within a few minutes) and it will no longer be used to identify this browser (or device) for your [Fingerprint Workspace](https://dev.fingerprint.com/docs/glossary#fingerprint-workspace).  #### Identification requests made from this browser (or device) - Fingerprint stores the identification requests made from a browser (or device) for up to 30 (or 90) days depending on your plan. To learn more, see [Data Retention](https://dev.fingerprint.com/docs/regions#data-retention). - Upon request to delete, the identification requests that were made by this browser   - Within the past 10 days are deleted within 24 hrs.   - Outside of 10 days are allowed to purge as per your data retention period.  ### Corollary After requesting to delete a visitor ID, - If the same browser (or device) requests to identify, it will receive a different visitor ID. - If you request [`/v4/events` API](https://dev.fingerprint.com/reference/getevent) with an `event_id` that was made outside of the 10 days, you will still receive a valid response.  ### Interested? Please [contact our support team](https://fingerprint.com/support/) to enable it for you. Otherwise, you will receive a 403. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="visitorId">The [visitor ID](https://dev.fingerprint.com/reference/get-function#visitorid) you want to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteVisitorDataApiResponse"/>&gt;</returns>
        Task<IDeleteVisitorDataApiResponse> DeleteVisitorDataAsync(string visitorId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete data by visitor ID
        /// </summary>
        /// <remarks>
        /// Request deleting all data associated with the specified visitor ID. This API is useful for compliance with privacy regulations.  ### Which data is deleted? - Browser (or device) properties - Identification requests made from this browser (or device)  #### Browser (or device) properties - Represents the data that Fingerprint collected from this specific browser (or device) and everything inferred and derived from it. - Upon request to delete, this data is deleted asynchronously (typically within a few minutes) and it will no longer be used to identify this browser (or device) for your [Fingerprint Workspace](https://dev.fingerprint.com/docs/glossary#fingerprint-workspace).  #### Identification requests made from this browser (or device) - Fingerprint stores the identification requests made from a browser (or device) for up to 30 (or 90) days depending on your plan. To learn more, see [Data Retention](https://dev.fingerprint.com/docs/regions#data-retention). - Upon request to delete, the identification requests that were made by this browser   - Within the past 10 days are deleted within 24 hrs.   - Outside of 10 days are allowed to purge as per your data retention period.  ### Corollary After requesting to delete a visitor ID, - If the same browser (or device) requests to identify, it will receive a different visitor ID. - If you request [&#x60;/v4/events&#x60; API](https://dev.fingerprint.com/reference/getevent) with an &#x60;event_id&#x60; that was made outside of the 10 days, you will still receive a valid response.  ### Interested? Please [contact our support team](https://fingerprint.com/support/) to enable it for you. Otherwise, you will receive a 403. 
        /// </remarks>
        /// <param name="visitorId">The [visitor ID](https://dev.fingerprint.com/reference/get-function#visitorid) you want to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteVisitorDataApiResponse"/>&gt;</returns>
        Task<IDeleteVisitorDataApiResponse> DeleteVisitorDataOrDefaultAsync(string visitorId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an event by event ID
        /// </summary>
        /// <remarks>
        /// Get a detailed analysis of an individual identification event, including Smart Signals.  Use `event_id` as the URL path parameter. This API method is scoped to a request, i.e. all returned information is by `event_id`. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The unique [identifier](https://dev.fingerprint.com/reference/get-function#requestid) of each identification request (`requestId` can be used in its place).</param>
        /// <param name="rulesetId">The ID of the ruleset to evaluate against the event, producing the action to take for this event. The resulting action is returned in the `rule_action` attribute of the response.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEventApiResponse"/>&gt;</returns>
        Task<IGetEventApiResponse> GetEventAsync(string eventId, Option<string> rulesetId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an event by event ID
        /// </summary>
        /// <remarks>
        /// Get a detailed analysis of an individual identification event, including Smart Signals.  Use &#x60;event_id&#x60; as the URL path parameter. This API method is scoped to a request, i.e. all returned information is by &#x60;event_id&#x60;. 
        /// </remarks>
        /// <param name="eventId">The unique [identifier](https://dev.fingerprint.com/reference/get-function#requestid) of each identification request (`requestId` can be used in its place).</param>
        /// <param name="rulesetId">The ID of the ruleset to evaluate against the event, producing the action to take for this event. The resulting action is returned in the `rule_action` attribute of the response.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEventApiResponse"/>&gt;</returns>
        Task<IGetEventApiResponse> GetEventOrDefaultAsync(string eventId, Option<string> rulesetId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search events
        /// </summary>
        /// <remarks>
        /// ## Search  The `/v4/events` endpoint provides a convenient way to search for past events based on specific parameters. Typical use cases and queries include:  - Searching for events associated with a single `visitor_id` within a time range to get historical behavior of a visitor. - Searching for events associated with a single `linked_id` within a time range to get all events associated with your internal account identifier. - Excluding all bot traffic from the query (`good` and `bad` bots)  If you don't provide `start` or `end` parameters, the default search range is the **last 7 days**.  ### Filtering events with the `suspect` flag  The `/v4/events` endpoint unlocks a powerful method for fraud protection analytics. The `suspect` flag is exposed in all events where it was previously set by the update API.  You can also apply the `suspect` query parameter as a filter to find all potentially fraudulent activity that you previously marked as `suspect`. This helps identify patterns of fraudulent behavior.  ### Environment scoping  If you use a secret key that is scoped to an environment, you will only get events associated with the same environment. With a workspace-scoped environment, you will get events from all environments.  Smart Signals not activated for your workspace or are not included in the response. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">The request parameters.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchEventsApiResponse"/>&gt;</returns>
        Task<ISearchEventsApiResponse> SearchEventsAsync(SearchEventsRequest request, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search events
        /// </summary>
        /// <remarks>
        /// ## Search  The &#x60;/v4/events&#x60; endpoint provides a convenient way to search for past events based on specific parameters. Typical use cases and queries include:  - Searching for events associated with a single &#x60;visitor_id&#x60; within a time range to get historical behavior of a visitor. - Searching for events associated with a single &#x60;linked_id&#x60; within a time range to get all events associated with your internal account identifier. - Excluding all bot traffic from the query (&#x60;good&#x60; and &#x60;bad&#x60; bots)  If you don&#39;t provide &#x60;start&#x60; or &#x60;end&#x60; parameters, the default search range is the **last 7 days**.  ### Filtering events with the &#x60;suspect&#x60; flag  The &#x60;/v4/events&#x60; endpoint unlocks a powerful method for fraud protection analytics. The &#x60;suspect&#x60; flag is exposed in all events where it was previously set by the update API.  You can also apply the &#x60;suspect&#x60; query parameter as a filter to find all potentially fraudulent activity that you previously marked as &#x60;suspect&#x60;. This helps identify patterns of fraudulent behavior.  ### Environment scoping  If you use a secret key that is scoped to an environment, you will only get events associated with the same environment. With a workspace-scoped environment, you will get events from all environments.  Smart Signals not activated for your workspace or are not included in the response. 
        /// </remarks>
        /// <param name="request">The request parameters.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchEventsApiResponse"/>&gt;</returns>
        Task<ISearchEventsApiResponse> SearchEventsOrDefaultAsync(SearchEventsRequest request, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update an event
        /// </summary>
        /// <remarks>
        /// Change information in existing events specified by `event_id` or *flag suspicious events*.  When an event is created, it can be assigned `linked_id` and `tags` submitted through the JS agent parameters.  This information might not have been available on the client initially, so the Server API permits updating these attributes after the fact.  **Warning** It's not possible to update events older than one month.   **Warning** Trying to update an event immediately after creation may temporarily result in an  error (HTTP 409 Conflict. The event is not mutable yet.) as the event is fully propagated across our systems. In such a case, simply retry the request. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The unique event [identifier](https://dev.fingerprint.com/reference/get-function#event_id).</param>
        /// <param name="eventUpdate"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateEventApiResponse"/>&gt;</returns>
        Task<IUpdateEventApiResponse> UpdateEventAsync(string eventId, EventUpdate eventUpdate, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update an event
        /// </summary>
        /// <remarks>
        /// Change information in existing events specified by &#x60;event_id&#x60; or *flag suspicious events*.  When an event is created, it can be assigned &#x60;linked_id&#x60; and &#x60;tags&#x60; submitted through the JS agent parameters.  This information might not have been available on the client initially, so the Server API permits updating these attributes after the fact.  **Warning** It&#39;s not possible to update events older than one month.   **Warning** Trying to update an event immediately after creation may temporarily result in an  error (HTTP 409 Conflict. The event is not mutable yet.) as the event is fully propagated across our systems. In such a case, simply retry the request. 
        /// </remarks>
        /// <param name="eventId">The unique event [identifier](https://dev.fingerprint.com/reference/get-function#event_id).</param>
        /// <param name="eventUpdate"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateEventApiResponse"/>&gt;</returns>
        Task<IUpdateEventApiResponse> UpdateEventOrDefaultAsync(string eventId, EventUpdate eventUpdate, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IDeleteVisitorDataApiResponse"/>
    /// </summary>
    public interface IDeleteVisitorDataApiResponse : Fingerprint.ServerSdk.Client.IApiResponse, IBadRequest<Fingerprint.ServerSdk.Model.ErrorResponse>, IForbidden<Fingerprint.ServerSdk.Model.ErrorResponse>, INotFound<Fingerprint.ServerSdk.Model.ErrorResponse>, ITooManyRequests<Fingerprint.ServerSdk.Model.ErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="IGetEventApiResponse"/>
    /// </summary>
    public interface IGetEventApiResponse : Fingerprint.ServerSdk.Client.IApiResponse, IOk<Fingerprint.ServerSdk.Model.Event>, IBadRequest<Fingerprint.ServerSdk.Model.ErrorResponse>, IForbidden<Fingerprint.ServerSdk.Model.ErrorResponse>, INotFound<Fingerprint.ServerSdk.Model.ErrorResponse>, ITooManyRequests<Fingerprint.ServerSdk.Model.ErrorResponse>, IInternalServerError<Fingerprint.ServerSdk.Model.ErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Request parameters for the SearchEvents operation.
    /// </summary>
    public class SearchEventsRequest
    {
        /// <summary>
        /// Limit the number of events returned.  (optional, default to 10)
        /// </summary>
        public Option<int> Limit { get; set; } = default;

        /// <summary>
        /// Use `pagination_key` to get the next page of results.  When more results are available (e.g., you requested up to 100 results for your query using `limit`, but there are more than 100 events total matching your request), the `pagination_key` field is added to the response. The key corresponds to the `timestamp` of the last returned event. In the following request, use that value in the `pagination_key` parameter to get the next page of results:  1. First request, returning most recent 200 events: `GET api-base-url/events?limit=100` 2. Use `response.pagination_key` to get the next page of results: `GET api-base-url/events?limit=100&pagination_key=1740815825085`  (optional)
        /// </summary>
        public Option<string> PaginationKey { get; set; } = default;

        /// <summary>
        /// Unique [visitor identifier](https://dev.fingerprint.com/reference/get-function#visitorid) issued by Fingerprint Identification and all active Smart Signals. Filter for events matching this `visitor_id`.  (optional)
        /// </summary>
        public Option<string> VisitorId { get; set; } = default;

        /// <summary>
        /// Filter events by the Bot Detection result, specifically:   `all` - events where any kind of bot was detected.   `good` - events where a good bot was detected.   `bad` - events where a bad bot was detected.   `none` - events where no bot was detected. > Note: When using this parameter, only events with the `botd.bot` property set to a valid value are returned. Events without a `botd` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<BotFilter> Bot { get; set; } = default;

        /// <summary>
        /// Filter events by IP address or IP range (if CIDR notation is used). If CIDR notation is not used, a /32 for IPv4 or /128 for IPv6 is assumed. Examples of range based queries: 10.0.0.0/24, 192.168.0.1/32  (optional)
        /// </summary>
        public Option<string> IpAddress { get; set; } = default;

        /// <summary>
        ///  (optional)
        /// </summary>
        public Option<string> Asn { get; set; } = default;

        /// <summary>
        /// Filter events by your custom identifier.  You can use [linked Ids](https://dev.fingerprint.com/reference/get-function#linkedid) to associate identification requests with your own identifier, for example, session Id, purchase Id, or transaction Id. You can then use this `linked_id` parameter to retrieve all events associated with your custom identifier.  (optional)
        /// </summary>
        public Option<string> LinkedId { get; set; } = default;

        /// <summary>
        /// Filter events by the URL (`url` property) associated with the event.  (optional)
        /// </summary>
        public Option<string> Url { get; set; } = default;

        /// <summary>
        /// Filter events by the origin field of the event. Origin could be the website domain or mobile app bundle ID (eg: com.foo.bar)  (optional)
        /// </summary>
        public Option<string> Origin { get; set; } = default;

        /// <summary>
        /// Filter events with a timestamp greater than the start time, in Unix time (milliseconds).  (optional)
        /// </summary>
        public Option<long> Start { get; set; } = default;

        /// <summary>
        /// Filter events with a timestamp smaller than the end time, in Unix time (milliseconds).  (optional)
        /// </summary>
        public Option<long> End { get; set; } = default;

        /// <summary>
        /// Sort events in reverse timestamp order.  (optional)
        /// </summary>
        public Option<bool> Reverse { get; set; } = default;

        /// <summary>
        /// Filter events previously tagged as suspicious via the [Update API](https://dev.fingerprint.com/reference/updateevent). > Note: When using this parameter, only events with the `suspect` property explicitly set to `true` or `false` are returned. Events with undefined `suspect` property are left out of the response.  (optional)
        /// </summary>
        public Option<bool> Suspect { get; set; } = default;

        /// <summary>
        /// Filter events by VPN Detection result. > Note: When using this parameter, only events with the `vpn` property set to `true` or `false` are returned. Events without a `vpn` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<bool> Vpn { get; set; } = default;

        /// <summary>
        /// Filter events by Virtual Machine Detection result. > Note: When using this parameter, only events with the `virtual_machine` property set to `true` or `false` are returned. Events without a `virtual_machine` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<bool> VirtualMachine { get; set; } = default;

        /// <summary>
        /// Filter events by Browser Tampering Detection result. > Note: When using this parameter, only events with the `tampering.result` property set to `true` or `false` are returned. Events without a `tampering` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<bool> Tampering { get; set; } = default;

        /// <summary>
        /// Filter events by Anti-detect Browser Detection result. > Note: When using this parameter, only events with the `tampering.anti_detect_browser` property set to `true` or `false` are returned. Events without a `tampering` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<bool> AntiDetectBrowser { get; set; } = default;

        /// <summary>
        /// Filter events by Browser Incognito Detection result. > Note: When using this parameter, only events with the `incognito` property set to `true` or `false` are returned. Events without an `incognito` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<bool> Incognito { get; set; } = default;

        /// <summary>
        /// Filter events by Privacy Settings Detection result. > Note: When using this parameter, only events with the `privacy_settings` property set to `true` or `false` are returned. Events without a `privacy_settings` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<bool> PrivacySettings { get; set; } = default;

        /// <summary>
        /// Filter events by Jailbroken Device Detection result. > Note: When using this parameter, only events with the `jailbroken` property set to `true` or `false` are returned. Events without a `jailbroken` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<bool> Jailbroken { get; set; } = default;

        /// <summary>
        /// Filter events by Frida Detection result. > Note: When using this parameter, only events with the `frida` property set to `true` or `false` are returned. Events without a `frida` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<bool> Frida { get; set; } = default;

        /// <summary>
        /// Filter events by Factory Reset Detection result. > Note: When using this parameter, only events with a `factory_reset` time. Events without a `factory_reset` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<bool> FactoryReset { get; set; } = default;

        /// <summary>
        /// Filter events by Cloned App Detection result. > Note: When using this parameter, only events with the `cloned_app` property set to `true` or `false` are returned. Events without a `cloned_app` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<bool> ClonedApp { get; set; } = default;

        /// <summary>
        /// Filter events by Android Emulator Detection result. > Note: When using this parameter, only events with the `emulator` property set to `true` or `false` are returned. Events without an `emulator` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<bool> Emulator { get; set; } = default;

        /// <summary>
        /// Filter events by Rooted Device Detection result. > Note: When using this parameter, only events with the `root_apps` property set to `true` or `false` are returned. Events without a `root_apps` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<bool> RootApps { get; set; } = default;

        /// <summary>
        /// Filter events by VPN Detection result confidence level. `high` - events with high VPN Detection confidence. `medium` - events with medium VPN Detection confidence. `low` - events with low VPN Detection confidence. > Note: When using this parameter, only events with the `vpn.confidence` property set to a valid value are returned. Events without a `vpn` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<VpnConfidenceFilter> VpnConfidence { get; set; } = default;

        /// <summary>
        /// Filter events with Suspect Score result above a provided minimum threshold. > Note: When using this parameter, only events where the `suspect_score` property set to a value exceeding your threshold are returned. Events without a `suspect_score` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<float> MinSuspectScore { get; set; } = default;

        /// <summary>
        /// Filter events by Developer Tools detection result. > Note: When using this parameter, only events with the `developer_tools` property set to `true` or `false` are returned. Events without a `developer_tools` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<bool> DeveloperTools { get; set; } = default;

        /// <summary>
        /// Filter events by Location Spoofing detection result. > Note: When using this parameter, only events with the `location_spoofing` property set to `true` or `false` are returned. Events without a `location_spoofing` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<bool> LocationSpoofing { get; set; } = default;

        /// <summary>
        /// Filter events by MITM (Man-in-the-Middle) Attack detection result. > Note: When using this parameter, only events with the `mitm_attack` property set to `true` or `false` are returned. Events without a `mitm_attack` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<bool> MitmAttack { get; set; } = default;

        /// <summary>
        /// Filter events by Proxy detection result. > Note: When using this parameter, only events with the `proxy` property set to `true` or `false` are returned. Events without a `proxy` Smart Signal result are left out of the response.  (optional)
        /// </summary>
        public Option<bool> Proxy { get; set; } = default;

        /// <summary>
        /// Filter events by a specific SDK version associated with the identification event (`sdk.version` property). Example: `3.11.14`  (optional)
        /// </summary>
        public Option<string> SdkVersion { get; set; } = default;

        /// <summary>
        /// Filter events by the SDK Platform associated with the identification event (`sdk.platform` property) . `js` - Javascript agent (Web). `ios` - Apple iOS based devices. `android` - Android based devices.  (optional)
        /// </summary>
        public Option<SdkPlatformFilter> SdkPlatform { get; set; } = default;

        /// <summary>
        /// Filter for events by providing one or more environment IDs (`environment_id` property).  (optional)
        /// </summary>
        public Option<List<string>> Environment { get; set; } = default;

        /// <summary>
        /// Filter events by the most precise Proximity ID provided by default. > Note: When using this parameter, only events with the `proximity.id` property matching the provided ID are returned. Events without a `proximity` result are left out of the response.  (optional)
        /// </summary>
        public Option<string> ProximityId { get; set; } = default;

        /// <summary>
        /// When set, the response will include a `total_hits` property with a count of total query matches across all pages, up to the specified limit.  (optional)
        /// </summary>
        public Option<long> TotalHits { get; set; } = default;

        /// <summary>
        /// Filter events by Tor Node detection result. > Note: When using this parameter, only events with the `tor_node` property set to `true` or `false` are returned. Events without a `tor_node` detection result are left out of the response.  (optional)
        /// </summary>
        public Option<bool> TorNode { get; set; } = default;

        /// <summary>
        /// Sets the limit parameter.
        /// </summary>
        /// <param name="value">Limit the number of events returned. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithLimit(int value)
        {
            Limit = new Option<int>(value);
            return this;
        }

        /// <summary>
        /// Sets the paginationKey parameter.
        /// </summary>
        /// <param name="value">Use `pagination_key` to get the next page of results.  When more results are available (e.g., you requested up to 100 results for your query using `limit`, but there are more than 100 events total matching your request), the `pagination_key` field is added to the response. The key corresponds to the `timestamp` of the last returned event. In the following request, use that value in the `pagination_key` parameter to get the next page of results:  1. First request, returning most recent 200 events: `GET api-base-url/events?limit=100` 2. Use `response.pagination_key` to get the next page of results: `GET api-base-url/events?limit=100&pagination_key=1740815825085` </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithPaginationKey(string value)
        {
            PaginationKey = new Option<string>(value);
            return this;
        }

        /// <summary>
        /// Sets the visitorId parameter.
        /// </summary>
        /// <param name="value">Unique [visitor identifier](https://dev.fingerprint.com/reference/get-function#visitorid) issued by Fingerprint Identification and all active Smart Signals. Filter for events matching this `visitor_id`. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithVisitorId(string value)
        {
            VisitorId = new Option<string>(value);
            return this;
        }

        /// <summary>
        /// Sets the bot parameter.
        /// </summary>
        /// <param name="value">Filter events by the Bot Detection result, specifically:   `all` - events where any kind of bot was detected.   `good` - events where a good bot was detected.   `bad` - events where a bad bot was detected.   `none` - events where no bot was detected. > Note: When using this parameter, only events with the `botd.bot` property set to a valid value are returned. Events without a `botd` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithBot(BotFilter value)
        {
            Bot = new Option<BotFilter>(value);
            return this;
        }

        /// <summary>
        /// Sets the ipAddress parameter.
        /// </summary>
        /// <param name="value">Filter events by IP address or IP range (if CIDR notation is used). If CIDR notation is not used, a /32 for IPv4 or /128 for IPv6 is assumed. Examples of range based queries: 10.0.0.0/24, 192.168.0.1/32 </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithIpAddress(string value)
        {
            IpAddress = new Option<string>(value);
            return this;
        }

        /// <summary>
        /// Sets the asn parameter.
        /// </summary>
        /// <param name="value"></param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithAsn(string value)
        {
            Asn = new Option<string>(value);
            return this;
        }

        /// <summary>
        /// Sets the linkedId parameter.
        /// </summary>
        /// <param name="value">Filter events by your custom identifier.  You can use [linked Ids](https://dev.fingerprint.com/reference/get-function#linkedid) to associate identification requests with your own identifier, for example, session Id, purchase Id, or transaction Id. You can then use this `linked_id` parameter to retrieve all events associated with your custom identifier. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithLinkedId(string value)
        {
            LinkedId = new Option<string>(value);
            return this;
        }

        /// <summary>
        /// Sets the url parameter.
        /// </summary>
        /// <param name="value">Filter events by the URL (`url` property) associated with the event. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithUrl(string value)
        {
            Url = new Option<string>(value);
            return this;
        }

        /// <summary>
        /// Sets the origin parameter.
        /// </summary>
        /// <param name="value">Filter events by the origin field of the event. Origin could be the website domain or mobile app bundle ID (eg: com.foo.bar) </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithOrigin(string value)
        {
            Origin = new Option<string>(value);
            return this;
        }

        /// <summary>
        /// Sets the start parameter.
        /// </summary>
        /// <param name="value">Filter events with a timestamp greater than the start time, in Unix time (milliseconds). </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithStart(long value)
        {
            Start = new Option<long>(value);
            return this;
        }

        /// <summary>
        /// Sets the end parameter.
        /// </summary>
        /// <param name="value">Filter events with a timestamp smaller than the end time, in Unix time (milliseconds). </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithEnd(long value)
        {
            End = new Option<long>(value);
            return this;
        }

        /// <summary>
        /// Sets the reverse parameter.
        /// </summary>
        /// <param name="value">Sort events in reverse timestamp order. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithReverse(bool value)
        {
            Reverse = new Option<bool>(value);
            return this;
        }

        /// <summary>
        /// Sets the suspect parameter.
        /// </summary>
        /// <param name="value">Filter events previously tagged as suspicious via the [Update API](https://dev.fingerprint.com/reference/updateevent). > Note: When using this parameter, only events with the `suspect` property explicitly set to `true` or `false` are returned. Events with undefined `suspect` property are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithSuspect(bool value)
        {
            Suspect = new Option<bool>(value);
            return this;
        }

        /// <summary>
        /// Sets the vpn parameter.
        /// </summary>
        /// <param name="value">Filter events by VPN Detection result. > Note: When using this parameter, only events with the `vpn` property set to `true` or `false` are returned. Events without a `vpn` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithVpn(bool value)
        {
            Vpn = new Option<bool>(value);
            return this;
        }

        /// <summary>
        /// Sets the virtualMachine parameter.
        /// </summary>
        /// <param name="value">Filter events by Virtual Machine Detection result. > Note: When using this parameter, only events with the `virtual_machine` property set to `true` or `false` are returned. Events without a `virtual_machine` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithVirtualMachine(bool value)
        {
            VirtualMachine = new Option<bool>(value);
            return this;
        }

        /// <summary>
        /// Sets the tampering parameter.
        /// </summary>
        /// <param name="value">Filter events by Browser Tampering Detection result. > Note: When using this parameter, only events with the `tampering.result` property set to `true` or `false` are returned. Events without a `tampering` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithTampering(bool value)
        {
            Tampering = new Option<bool>(value);
            return this;
        }

        /// <summary>
        /// Sets the antiDetectBrowser parameter.
        /// </summary>
        /// <param name="value">Filter events by Anti-detect Browser Detection result. > Note: When using this parameter, only events with the `tampering.anti_detect_browser` property set to `true` or `false` are returned. Events without a `tampering` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithAntiDetectBrowser(bool value)
        {
            AntiDetectBrowser = new Option<bool>(value);
            return this;
        }

        /// <summary>
        /// Sets the incognito parameter.
        /// </summary>
        /// <param name="value">Filter events by Browser Incognito Detection result. > Note: When using this parameter, only events with the `incognito` property set to `true` or `false` are returned. Events without an `incognito` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithIncognito(bool value)
        {
            Incognito = new Option<bool>(value);
            return this;
        }

        /// <summary>
        /// Sets the privacySettings parameter.
        /// </summary>
        /// <param name="value">Filter events by Privacy Settings Detection result. > Note: When using this parameter, only events with the `privacy_settings` property set to `true` or `false` are returned. Events without a `privacy_settings` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithPrivacySettings(bool value)
        {
            PrivacySettings = new Option<bool>(value);
            return this;
        }

        /// <summary>
        /// Sets the jailbroken parameter.
        /// </summary>
        /// <param name="value">Filter events by Jailbroken Device Detection result. > Note: When using this parameter, only events with the `jailbroken` property set to `true` or `false` are returned. Events without a `jailbroken` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithJailbroken(bool value)
        {
            Jailbroken = new Option<bool>(value);
            return this;
        }

        /// <summary>
        /// Sets the frida parameter.
        /// </summary>
        /// <param name="value">Filter events by Frida Detection result. > Note: When using this parameter, only events with the `frida` property set to `true` or `false` are returned. Events without a `frida` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithFrida(bool value)
        {
            Frida = new Option<bool>(value);
            return this;
        }

        /// <summary>
        /// Sets the factoryReset parameter.
        /// </summary>
        /// <param name="value">Filter events by Factory Reset Detection result. > Note: When using this parameter, only events with a `factory_reset` time. Events without a `factory_reset` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithFactoryReset(bool value)
        {
            FactoryReset = new Option<bool>(value);
            return this;
        }

        /// <summary>
        /// Sets the clonedApp parameter.
        /// </summary>
        /// <param name="value">Filter events by Cloned App Detection result. > Note: When using this parameter, only events with the `cloned_app` property set to `true` or `false` are returned. Events without a `cloned_app` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithClonedApp(bool value)
        {
            ClonedApp = new Option<bool>(value);
            return this;
        }

        /// <summary>
        /// Sets the emulator parameter.
        /// </summary>
        /// <param name="value">Filter events by Android Emulator Detection result. > Note: When using this parameter, only events with the `emulator` property set to `true` or `false` are returned. Events without an `emulator` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithEmulator(bool value)
        {
            Emulator = new Option<bool>(value);
            return this;
        }

        /// <summary>
        /// Sets the rootApps parameter.
        /// </summary>
        /// <param name="value">Filter events by Rooted Device Detection result. > Note: When using this parameter, only events with the `root_apps` property set to `true` or `false` are returned. Events without a `root_apps` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithRootApps(bool value)
        {
            RootApps = new Option<bool>(value);
            return this;
        }

        /// <summary>
        /// Sets the vpnConfidence parameter.
        /// </summary>
        /// <param name="value">Filter events by VPN Detection result confidence level. `high` - events with high VPN Detection confidence. `medium` - events with medium VPN Detection confidence. `low` - events with low VPN Detection confidence. > Note: When using this parameter, only events with the `vpn.confidence` property set to a valid value are returned. Events without a `vpn` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithVpnConfidence(VpnConfidenceFilter value)
        {
            VpnConfidence = new Option<VpnConfidenceFilter>(value);
            return this;
        }

        /// <summary>
        /// Sets the minSuspectScore parameter.
        /// </summary>
        /// <param name="value">Filter events with Suspect Score result above a provided minimum threshold. > Note: When using this parameter, only events where the `suspect_score` property set to a value exceeding your threshold are returned. Events without a `suspect_score` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithMinSuspectScore(float value)
        {
            MinSuspectScore = new Option<float>(value);
            return this;
        }

        /// <summary>
        /// Sets the developerTools parameter.
        /// </summary>
        /// <param name="value">Filter events by Developer Tools detection result. > Note: When using this parameter, only events with the `developer_tools` property set to `true` or `false` are returned. Events without a `developer_tools` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithDeveloperTools(bool value)
        {
            DeveloperTools = new Option<bool>(value);
            return this;
        }

        /// <summary>
        /// Sets the locationSpoofing parameter.
        /// </summary>
        /// <param name="value">Filter events by Location Spoofing detection result. > Note: When using this parameter, only events with the `location_spoofing` property set to `true` or `false` are returned. Events without a `location_spoofing` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithLocationSpoofing(bool value)
        {
            LocationSpoofing = new Option<bool>(value);
            return this;
        }

        /// <summary>
        /// Sets the mitmAttack parameter.
        /// </summary>
        /// <param name="value">Filter events by MITM (Man-in-the-Middle) Attack detection result. > Note: When using this parameter, only events with the `mitm_attack` property set to `true` or `false` are returned. Events without a `mitm_attack` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithMitmAttack(bool value)
        {
            MitmAttack = new Option<bool>(value);
            return this;
        }

        /// <summary>
        /// Sets the proxy parameter.
        /// </summary>
        /// <param name="value">Filter events by Proxy detection result. > Note: When using this parameter, only events with the `proxy` property set to `true` or `false` are returned. Events without a `proxy` Smart Signal result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithProxy(bool value)
        {
            Proxy = new Option<bool>(value);
            return this;
        }

        /// <summary>
        /// Sets the sdkVersion parameter.
        /// </summary>
        /// <param name="value">Filter events by a specific SDK version associated with the identification event (`sdk.version` property). Example: `3.11.14` </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithSdkVersion(string value)
        {
            SdkVersion = new Option<string>(value);
            return this;
        }

        /// <summary>
        /// Sets the sdkPlatform parameter.
        /// </summary>
        /// <param name="value">Filter events by the SDK Platform associated with the identification event (`sdk.platform` property) . `js` - Javascript agent (Web). `ios` - Apple iOS based devices. `android` - Android based devices. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithSdkPlatform(SdkPlatformFilter value)
        {
            SdkPlatform = new Option<SdkPlatformFilter>(value);
            return this;
        }

        /// <summary>
        /// Sets the environment parameter.
        /// </summary>
        /// <param name="value">Filter for events by providing one or more environment IDs (`environment_id` property). </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithEnvironment(List<string> value)
        {
            Environment = new Option<List<string>>(value);
            return this;
        }

        /// <summary>
        /// Sets the proximityId parameter.
        /// </summary>
        /// <param name="value">Filter events by the most precise Proximity ID provided by default. > Note: When using this parameter, only events with the `proximity.id` property matching the provided ID are returned. Events without a `proximity` result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithProximityId(string value)
        {
            ProximityId = new Option<string>(value);
            return this;
        }

        /// <summary>
        /// Sets the totalHits parameter.
        /// </summary>
        /// <param name="value">When set, the response will include a `total_hits` property with a count of total query matches across all pages, up to the specified limit. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithTotalHits(long value)
        {
            TotalHits = new Option<long>(value);
            return this;
        }

        /// <summary>
        /// Sets the torNode parameter.
        /// </summary>
        /// <param name="value">Filter events by Tor Node detection result. > Note: When using this parameter, only events with the `tor_node` property set to `true` or `false` are returned. Events without a `tor_node` detection result are left out of the response. </param>
        /// <returns>This request instance for fluent chaining.</returns>
        public SearchEventsRequest WithTorNode(bool value)
        {
            TorNode = new Option<bool>(value);
            return this;
        }

    }

    /// <summary>
    /// The <see cref="ISearchEventsApiResponse"/>
    /// </summary>
    public interface ISearchEventsApiResponse : Fingerprint.ServerSdk.Client.IApiResponse, IOk<Fingerprint.ServerSdk.Model.EventSearch>, IBadRequest<Fingerprint.ServerSdk.Model.ErrorResponse>, IForbidden<Fingerprint.ServerSdk.Model.ErrorResponse>, IInternalServerError<Fingerprint.ServerSdk.Model.ErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateEventApiResponse"/>
    /// </summary>
    public interface IUpdateEventApiResponse : Fingerprint.ServerSdk.Client.IApiResponse, IBadRequest<Fingerprint.ServerSdk.Model.ErrorResponse>, IForbidden<Fingerprint.ServerSdk.Model.ErrorResponse>, INotFound<Fingerprint.ServerSdk.Model.ErrorResponse>, IConflict<Fingerprint.ServerSdk.Model.ErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class FingerprintApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDeleteVisitorData;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDeleteVisitorData;

        internal void ExecuteOnDeleteVisitorData(FingerprintApi.DeleteVisitorDataApiResponse apiResponse)
        {
            OnDeleteVisitorData?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteVisitorData(Exception exception)
        {
            OnErrorDeleteVisitorData?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEvent;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEvent;

        internal void ExecuteOnGetEvent(FingerprintApi.GetEventApiResponse apiResponse)
        {
            OnGetEvent?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEvent(Exception exception)
        {
            OnErrorGetEvent?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnSearchEvents;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorSearchEvents;

        internal void ExecuteOnSearchEvents(FingerprintApi.SearchEventsApiResponse apiResponse)
        {
            OnSearchEvents?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchEvents(Exception exception)
        {
            OnErrorSearchEvents?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnUpdateEvent;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorUpdateEvent;

        internal void ExecuteOnUpdateEvent(FingerprintApi.UpdateEventApiResponse apiResponse)
        {
            OnUpdateEvent?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateEvent(Exception exception)
        {
            OnErrorUpdateEvent?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class FingerprintApi : IFingerprintApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<FingerprintApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public FingerprintApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="FingerprintApi"/> class.
        /// </summary>
        /// <returns></returns>
        public FingerprintApi(ILogger<FingerprintApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, FingerprintApiEvents fingerprintApiEvents,
            TokenProvider<BearerToken> bearerTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<FingerprintApi>();
            HttpClient = httpClient;
            Events = fingerprintApiEvents;
            BearerTokenProvider = bearerTokenProvider;
        }

        partial void FormatDeleteVisitorData(ref string visitorId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="visitorId"></param>
        /// <returns></returns>
        private void ValidateDeleteVisitorData(string visitorId)
        {
            if (visitorId == null)
                throw new ArgumentNullException(nameof(visitorId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="visitorId"></param>
        private void AfterDeleteVisitorDataDefaultImplementation(IDeleteVisitorDataApiResponse apiResponseLocalVar, string visitorId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteVisitorData(ref suppressDefaultLog, apiResponseLocalVar, visitorId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="visitorId"></param>
        partial void AfterDeleteVisitorData(ref bool suppressDefaultLog, IDeleteVisitorDataApiResponse apiResponseLocalVar, string visitorId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="visitorId"></param>
        private void OnErrorDeleteVisitorDataDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string visitorId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteVisitorData(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, visitorId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="visitorId"></param>
        partial void OnErrorDeleteVisitorData(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string visitorId);

        /// <summary>
        /// Delete data by visitor ID Request deleting all data associated with the specified visitor ID. This API is useful for compliance with privacy regulations.  ### Which data is deleted? - Browser (or device) properties - Identification requests made from this browser (or device)  #### Browser (or device) properties - Represents the data that Fingerprint collected from this specific browser (or device) and everything inferred and derived from it. - Upon request to delete, this data is deleted asynchronously (typically within a few minutes) and it will no longer be used to identify this browser (or device) for your [Fingerprint Workspace](https://dev.fingerprint.com/docs/glossary#fingerprint-workspace).  #### Identification requests made from this browser (or device) - Fingerprint stores the identification requests made from a browser (or device) for up to 30 (or 90) days depending on your plan. To learn more, see [Data Retention](https://dev.fingerprint.com/docs/regions#data-retention). - Upon request to delete, the identification requests that were made by this browser   - Within the past 10 days are deleted within 24 hrs.   - Outside of 10 days are allowed to purge as per your data retention period.  ### Corollary After requesting to delete a visitor ID, - If the same browser (or device) requests to identify, it will receive a different visitor ID. - If you request [&#x60;/v4/events&#x60; API](https://dev.fingerprint.com/reference/getevent) with an &#x60;event_id&#x60; that was made outside of the 10 days, you will still receive a valid response.  ### Interested? Please [contact our support team](https://fingerprint.com/support/) to enable it for you. Otherwise, you will receive a 403. 
        /// </summary>
        /// <param name="visitorId">The [visitor ID](https://dev.fingerprint.com/reference/get-function#visitorid) you want to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteVisitorDataApiResponse"/>&gt;</returns>
        public async Task<IDeleteVisitorDataApiResponse> DeleteVisitorDataOrDefaultAsync(string visitorId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteVisitorDataAsync(visitorId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete data by visitor ID
        /// </summary>
        /// <remarks>
        /// Request deleting all data associated with the specified visitor ID. This API is useful for compliance with privacy regulations.  ### Which data is deleted? - Browser (or device) properties - Identification requests made from this browser (or device)  #### Browser (or device) properties - Represents the data that Fingerprint collected from this specific browser (or device) and everything inferred and derived from it. - Upon request to delete, this data is deleted asynchronously (typically within a few minutes) and it will no longer be used to identify this browser (or device) for your [Fingerprint Workspace](https://dev.fingerprint.com/docs/glossary#fingerprint-workspace).  #### Identification requests made from this browser (or device) - Fingerprint stores the identification requests made from a browser (or device) for up to 30 (or 90) days depending on your plan. To learn more, see [Data Retention](https://dev.fingerprint.com/docs/regions#data-retention). - Upon request to delete, the identification requests that were made by this browser   - Within the past 10 days are deleted within 24 hrs.   - Outside of 10 days are allowed to purge as per your data retention period.  ### Corollary After requesting to delete a visitor ID, - If the same browser (or device) requests to identify, it will receive a different visitor ID. - If you request [`/v4/events` API](https://dev.fingerprint.com/reference/getevent) with an `event_id` that was made outside of the 10 days, you will still receive a valid response.  ### Interested? Please [contact our support team](https://fingerprint.com/support/) to enable it for you. Otherwise, you will receive a 403. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="visitorId">The [visitor ID](https://dev.fingerprint.com/reference/get-function#visitorid) you want to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteVisitorDataApiResponse"/>&gt;</returns>
        public async Task<IDeleteVisitorDataApiResponse> DeleteVisitorDataAsync(string visitorId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteVisitorData(visitorId);

                FormatDeleteVisitorData(ref visitorId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/visitors/{visitor_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/visitors/{visitor_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bvisitor_id%7D", Uri.EscapeDataString(visitorId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);
                    parseQueryStringLocalVar["ii"] = $"fingerprint-pro-server-api-dotnet-sdk/{ClientUtils.ClientVersion}";

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();
                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("DELETE");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DeleteVisitorDataApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteVisitorDataApiResponse>();
                        DeleteVisitorDataApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode)
                        {
                            default:
                                {
                                    string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);
                                    apiResponseLocalVar = new DeleteVisitorDataApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/visitors/{visitor_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                    break;
                                }
                        }

                        AfterDeleteVisitorDataDefaultImplementation(apiResponseLocalVar, visitorId);

                        Events.ExecuteOnDeleteVisitorData(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode)429)
                            foreach (TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch (Exception e)
            {
                OnErrorDeleteVisitorDataDefaultImplementation(e, "/visitors/{visitor_id}", uriBuilderLocalVar.Path, visitorId);
                Events.ExecuteOnErrorDeleteVisitorData(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteVisitorDataApiResponse"/>
        /// </summary>
        public partial class DeleteVisitorDataApiResponse : Fingerprint.ServerSdk.Client.ApiResponse, IDeleteVisitorDataApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteVisitorDataApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteVisitorDataApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteVisitorDataApiResponse(ILogger<DeleteVisitorDataApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DeleteVisitorDataApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteVisitorDataApiResponse(ILogger<DeleteVisitorDataApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Fingerprint.ServerSdk.Model.ErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Fingerprint.ServerSdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest(out Fingerprint.ServerSdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                }
                catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public Fingerprint.ServerSdk.Model.ErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<Fingerprint.ServerSdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden(out Fingerprint.ServerSdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                }
                catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Fingerprint.ServerSdk.Model.ErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Fingerprint.ServerSdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound(out Fingerprint.ServerSdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                }
                catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Fingerprint.ServerSdk.Model.ErrorResponse TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Fingerprint.ServerSdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests(out Fingerprint.ServerSdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                }
                catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEvent(ref string eventId, ref Option<string> rulesetId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="eventId"></param>
        /// <param name="rulesetId"></param>
        /// <returns></returns>
        private void ValidateGetEvent(string eventId, Option<string> rulesetId)
        {
            if (eventId == null)
                throw new ArgumentNullException(nameof(eventId));

            if (rulesetId.IsSet && rulesetId.Value == null)
                throw new ArgumentNullException(nameof(rulesetId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="eventId"></param>
        /// <param name="rulesetId"></param>
        private void AfterGetEventDefaultImplementation(IGetEventApiResponse apiResponseLocalVar, string eventId, Option<string> rulesetId)
        {
            bool suppressDefaultLog = false;
            AfterGetEvent(ref suppressDefaultLog, apiResponseLocalVar, eventId, rulesetId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="eventId"></param>
        /// <param name="rulesetId"></param>
        partial void AfterGetEvent(ref bool suppressDefaultLog, IGetEventApiResponse apiResponseLocalVar, string eventId, Option<string> rulesetId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="eventId"></param>
        /// <param name="rulesetId"></param>
        private void OnErrorGetEventDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string eventId, Option<string> rulesetId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEvent(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, eventId, rulesetId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="eventId"></param>
        /// <param name="rulesetId"></param>
        partial void OnErrorGetEvent(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string eventId, Option<string> rulesetId);

        /// <summary>
        /// Get an event by event ID Get a detailed analysis of an individual identification event, including Smart Signals.  Use &#x60;event_id&#x60; as the URL path parameter. This API method is scoped to a request, i.e. all returned information is by &#x60;event_id&#x60;. 
        /// </summary>
        /// <param name="eventId">The unique [identifier](https://dev.fingerprint.com/reference/get-function#requestid) of each identification request (&#x60;requestId&#x60; can be used in its place).</param>
        /// <param name="rulesetId">The ID of the ruleset to evaluate against the event, producing the action to take for this event. The resulting action is returned in the &#x60;rule_action&#x60; attribute of the response.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEventApiResponse"/>&gt;</returns>
        public async Task<IGetEventApiResponse> GetEventOrDefaultAsync(string eventId, Option<string> rulesetId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEventAsync(eventId, rulesetId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get an event by event ID
        /// </summary>
        /// <remarks>
        /// Get a detailed analysis of an individual identification event, including Smart Signals.  Use `event_id` as the URL path parameter. This API method is scoped to a request, i.e. all returned information is by `event_id`. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The unique [identifier](https://dev.fingerprint.com/reference/get-function#requestid) of each identification request (`requestId` can be used in its place).</param>
        /// <param name="rulesetId">The ID of the ruleset to evaluate against the event, producing the action to take for this event. The resulting action is returned in the `rule_action` attribute of the response.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEventApiResponse"/>&gt;</returns>
        public async Task<IGetEventApiResponse> GetEventAsync(string eventId, Option<string> rulesetId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetEvent(eventId, rulesetId);

                FormatGetEvent(ref eventId, ref rulesetId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/events/{event_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/events/{event_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bevent_id%7D", Uri.EscapeDataString(eventId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);
                    parseQueryStringLocalVar["ii"] = $"fingerprint-pro-server-api-dotnet-sdk/{ClientUtils.ClientVersion}";

                    if (rulesetId.IsSet)
                        parseQueryStringLocalVar["ruleset_id"] = ClientUtils.ParameterToString(rulesetId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();
                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetEventApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEventApiResponse>();
                        GetEventApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode)
                        {
                            default:
                                {
                                    string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);
                                    apiResponseLocalVar = new GetEventApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/events/{event_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                    break;
                                }
                        }

                        AfterGetEventDefaultImplementation(apiResponseLocalVar, eventId, rulesetId);

                        Events.ExecuteOnGetEvent(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode)429)
                            foreach (TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch (Exception e)
            {
                OnErrorGetEventDefaultImplementation(e, "/events/{event_id}", uriBuilderLocalVar.Path, eventId, rulesetId);
                Events.ExecuteOnErrorGetEvent(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEventApiResponse"/>
        /// </summary>
        public partial class GetEventApiResponse : Fingerprint.ServerSdk.Client.ApiResponse, IGetEventApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEventApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEventApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEventApiResponse(ILogger<GetEventApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetEventApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEventApiResponse(ILogger<GetEventApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Fingerprint.ServerSdk.Model.Event Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Fingerprint.ServerSdk.Model.Event>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out Fingerprint.ServerSdk.Model.Event result)
            {
                result = null;

                try
                {
                    result = Ok();
                }
                catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Fingerprint.ServerSdk.Model.ErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Fingerprint.ServerSdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest(out Fingerprint.ServerSdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                }
                catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public Fingerprint.ServerSdk.Model.ErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<Fingerprint.ServerSdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden(out Fingerprint.ServerSdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                }
                catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Fingerprint.ServerSdk.Model.ErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Fingerprint.ServerSdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound(out Fingerprint.ServerSdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                }
                catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Fingerprint.ServerSdk.Model.ErrorResponse TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Fingerprint.ServerSdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests(out Fingerprint.ServerSdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                }
                catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Fingerprint.ServerSdk.Model.ErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Fingerprint.ServerSdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError(out Fingerprint.ServerSdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                }
                catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchEvents(ref Option<int> limit, ref Option<string> paginationKey, ref Option<string> visitorId, ref Option<BotFilter> bot, ref Option<string> ipAddress, ref Option<string> asn, ref Option<string> linkedId, ref Option<string> url, ref Option<string> origin, ref Option<long> start, ref Option<long> end, ref Option<bool> reverse, ref Option<bool> suspect, ref Option<bool> vpn, ref Option<bool> virtualMachine, ref Option<bool> tampering, ref Option<bool> antiDetectBrowser, ref Option<bool> incognito, ref Option<bool> privacySettings, ref Option<bool> jailbroken, ref Option<bool> frida, ref Option<bool> factoryReset, ref Option<bool> clonedApp, ref Option<bool> emulator, ref Option<bool> rootApps, ref Option<VpnConfidenceFilter> vpnConfidence, ref Option<float> minSuspectScore, ref Option<bool> developerTools, ref Option<bool> locationSpoofing, ref Option<bool> mitmAttack, ref Option<bool> proxy, ref Option<string> sdkVersion, ref Option<SdkPlatformFilter> sdkPlatform, Option<List<string>> environment, ref Option<string> proximityId, ref Option<long> totalHits, ref Option<bool> torNode);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="paginationKey"></param>
        /// <param name="visitorId"></param>
        /// <param name="ipAddress"></param>
        /// <param name="asn"></param>
        /// <param name="linkedId"></param>
        /// <param name="url"></param>
        /// <param name="origin"></param>
        /// <param name="sdkVersion"></param>
        /// <param name="environment"></param>
        /// <param name="proximityId"></param>
        /// <returns></returns>
        private void ValidateSearchEvents(Option<string> paginationKey, Option<string> visitorId, Option<string> ipAddress, Option<string> asn, Option<string> linkedId, Option<string> url, Option<string> origin, Option<string> sdkVersion, Option<List<string>> environment, Option<string> proximityId)
        {
            if (paginationKey.IsSet && paginationKey.Value == null)
                throw new ArgumentNullException(nameof(paginationKey));

            if (visitorId.IsSet && visitorId.Value == null)
                throw new ArgumentNullException(nameof(visitorId));

            if (ipAddress.IsSet && ipAddress.Value == null)
                throw new ArgumentNullException(nameof(ipAddress));

            if (asn.IsSet && asn.Value == null)
                throw new ArgumentNullException(nameof(asn));

            if (linkedId.IsSet && linkedId.Value == null)
                throw new ArgumentNullException(nameof(linkedId));

            if (url.IsSet && url.Value == null)
                throw new ArgumentNullException(nameof(url));

            if (origin.IsSet && origin.Value == null)
                throw new ArgumentNullException(nameof(origin));

            if (sdkVersion.IsSet && sdkVersion.Value == null)
                throw new ArgumentNullException(nameof(sdkVersion));

            if (environment.IsSet && environment.Value == null)
                throw new ArgumentNullException(nameof(environment));

            if (proximityId.IsSet && proximityId.Value == null)
                throw new ArgumentNullException(nameof(proximityId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="limit"></param>
        /// <param name="paginationKey"></param>
        /// <param name="visitorId"></param>
        /// <param name="bot"></param>
        /// <param name="ipAddress"></param>
        /// <param name="asn"></param>
        /// <param name="linkedId"></param>
        /// <param name="url"></param>
        /// <param name="origin"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="reverse"></param>
        /// <param name="suspect"></param>
        /// <param name="vpn"></param>
        /// <param name="virtualMachine"></param>
        /// <param name="tampering"></param>
        /// <param name="antiDetectBrowser"></param>
        /// <param name="incognito"></param>
        /// <param name="privacySettings"></param>
        /// <param name="jailbroken"></param>
        /// <param name="frida"></param>
        /// <param name="factoryReset"></param>
        /// <param name="clonedApp"></param>
        /// <param name="emulator"></param>
        /// <param name="rootApps"></param>
        /// <param name="vpnConfidence"></param>
        /// <param name="minSuspectScore"></param>
        /// <param name="developerTools"></param>
        /// <param name="locationSpoofing"></param>
        /// <param name="mitmAttack"></param>
        /// <param name="proxy"></param>
        /// <param name="sdkVersion"></param>
        /// <param name="sdkPlatform"></param>
        /// <param name="environment"></param>
        /// <param name="proximityId"></param>
        /// <param name="totalHits"></param>
        /// <param name="torNode"></param>
        private void AfterSearchEventsDefaultImplementation(ISearchEventsApiResponse apiResponseLocalVar, Option<int> limit, Option<string> paginationKey, Option<string> visitorId, Option<BotFilter> bot, Option<string> ipAddress, Option<string> asn, Option<string> linkedId, Option<string> url, Option<string> origin, Option<long> start, Option<long> end, Option<bool> reverse, Option<bool> suspect, Option<bool> vpn, Option<bool> virtualMachine, Option<bool> tampering, Option<bool> antiDetectBrowser, Option<bool> incognito, Option<bool> privacySettings, Option<bool> jailbroken, Option<bool> frida, Option<bool> factoryReset, Option<bool> clonedApp, Option<bool> emulator, Option<bool> rootApps, Option<VpnConfidenceFilter> vpnConfidence, Option<float> minSuspectScore, Option<bool> developerTools, Option<bool> locationSpoofing, Option<bool> mitmAttack, Option<bool> proxy, Option<string> sdkVersion, Option<SdkPlatformFilter> sdkPlatform, Option<List<string>> environment, Option<string> proximityId, Option<long> totalHits, Option<bool> torNode)
        {
            bool suppressDefaultLog = false;
            AfterSearchEvents(ref suppressDefaultLog, apiResponseLocalVar, limit, paginationKey, visitorId, bot, ipAddress, asn, linkedId, url, origin, start, end, reverse, suspect, vpn, virtualMachine, tampering, antiDetectBrowser, incognito, privacySettings, jailbroken, frida, factoryReset, clonedApp, emulator, rootApps, vpnConfidence, minSuspectScore, developerTools, locationSpoofing, mitmAttack, proxy, sdkVersion, sdkPlatform, environment, proximityId, totalHits, torNode);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="limit"></param>
        /// <param name="paginationKey"></param>
        /// <param name="visitorId"></param>
        /// <param name="bot"></param>
        /// <param name="ipAddress"></param>
        /// <param name="asn"></param>
        /// <param name="linkedId"></param>
        /// <param name="url"></param>
        /// <param name="origin"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="reverse"></param>
        /// <param name="suspect"></param>
        /// <param name="vpn"></param>
        /// <param name="virtualMachine"></param>
        /// <param name="tampering"></param>
        /// <param name="antiDetectBrowser"></param>
        /// <param name="incognito"></param>
        /// <param name="privacySettings"></param>
        /// <param name="jailbroken"></param>
        /// <param name="frida"></param>
        /// <param name="factoryReset"></param>
        /// <param name="clonedApp"></param>
        /// <param name="emulator"></param>
        /// <param name="rootApps"></param>
        /// <param name="vpnConfidence"></param>
        /// <param name="minSuspectScore"></param>
        /// <param name="developerTools"></param>
        /// <param name="locationSpoofing"></param>
        /// <param name="mitmAttack"></param>
        /// <param name="proxy"></param>
        /// <param name="sdkVersion"></param>
        /// <param name="sdkPlatform"></param>
        /// <param name="environment"></param>
        /// <param name="proximityId"></param>
        /// <param name="totalHits"></param>
        /// <param name="torNode"></param>
        partial void AfterSearchEvents(ref bool suppressDefaultLog, ISearchEventsApiResponse apiResponseLocalVar, Option<int> limit, Option<string> paginationKey, Option<string> visitorId, Option<BotFilter> bot, Option<string> ipAddress, Option<string> asn, Option<string> linkedId, Option<string> url, Option<string> origin, Option<long> start, Option<long> end, Option<bool> reverse, Option<bool> suspect, Option<bool> vpn, Option<bool> virtualMachine, Option<bool> tampering, Option<bool> antiDetectBrowser, Option<bool> incognito, Option<bool> privacySettings, Option<bool> jailbroken, Option<bool> frida, Option<bool> factoryReset, Option<bool> clonedApp, Option<bool> emulator, Option<bool> rootApps, Option<VpnConfidenceFilter> vpnConfidence, Option<float> minSuspectScore, Option<bool> developerTools, Option<bool> locationSpoofing, Option<bool> mitmAttack, Option<bool> proxy, Option<string> sdkVersion, Option<SdkPlatformFilter> sdkPlatform, Option<List<string>> environment, Option<string> proximityId, Option<long> totalHits, Option<bool> torNode);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="limit"></param>
        /// <param name="paginationKey"></param>
        /// <param name="visitorId"></param>
        /// <param name="bot"></param>
        /// <param name="ipAddress"></param>
        /// <param name="asn"></param>
        /// <param name="linkedId"></param>
        /// <param name="url"></param>
        /// <param name="origin"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="reverse"></param>
        /// <param name="suspect"></param>
        /// <param name="vpn"></param>
        /// <param name="virtualMachine"></param>
        /// <param name="tampering"></param>
        /// <param name="antiDetectBrowser"></param>
        /// <param name="incognito"></param>
        /// <param name="privacySettings"></param>
        /// <param name="jailbroken"></param>
        /// <param name="frida"></param>
        /// <param name="factoryReset"></param>
        /// <param name="clonedApp"></param>
        /// <param name="emulator"></param>
        /// <param name="rootApps"></param>
        /// <param name="vpnConfidence"></param>
        /// <param name="minSuspectScore"></param>
        /// <param name="developerTools"></param>
        /// <param name="locationSpoofing"></param>
        /// <param name="mitmAttack"></param>
        /// <param name="proxy"></param>
        /// <param name="sdkVersion"></param>
        /// <param name="sdkPlatform"></param>
        /// <param name="environment"></param>
        /// <param name="proximityId"></param>
        /// <param name="totalHits"></param>
        /// <param name="torNode"></param>
        private void OnErrorSearchEventsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> limit, Option<string> paginationKey, Option<string> visitorId, Option<BotFilter> bot, Option<string> ipAddress, Option<string> asn, Option<string> linkedId, Option<string> url, Option<string> origin, Option<long> start, Option<long> end, Option<bool> reverse, Option<bool> suspect, Option<bool> vpn, Option<bool> virtualMachine, Option<bool> tampering, Option<bool> antiDetectBrowser, Option<bool> incognito, Option<bool> privacySettings, Option<bool> jailbroken, Option<bool> frida, Option<bool> factoryReset, Option<bool> clonedApp, Option<bool> emulator, Option<bool> rootApps, Option<VpnConfidenceFilter> vpnConfidence, Option<float> minSuspectScore, Option<bool> developerTools, Option<bool> locationSpoofing, Option<bool> mitmAttack, Option<bool> proxy, Option<string> sdkVersion, Option<SdkPlatformFilter> sdkPlatform, Option<List<string>> environment, Option<string> proximityId, Option<long> totalHits, Option<bool> torNode)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchEvents(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, limit, paginationKey, visitorId, bot, ipAddress, asn, linkedId, url, origin, start, end, reverse, suspect, vpn, virtualMachine, tampering, antiDetectBrowser, incognito, privacySettings, jailbroken, frida, factoryReset, clonedApp, emulator, rootApps, vpnConfidence, minSuspectScore, developerTools, locationSpoofing, mitmAttack, proxy, sdkVersion, sdkPlatform, environment, proximityId, totalHits, torNode);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="limit"></param>
        /// <param name="paginationKey"></param>
        /// <param name="visitorId"></param>
        /// <param name="bot"></param>
        /// <param name="ipAddress"></param>
        /// <param name="asn"></param>
        /// <param name="linkedId"></param>
        /// <param name="url"></param>
        /// <param name="origin"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="reverse"></param>
        /// <param name="suspect"></param>
        /// <param name="vpn"></param>
        /// <param name="virtualMachine"></param>
        /// <param name="tampering"></param>
        /// <param name="antiDetectBrowser"></param>
        /// <param name="incognito"></param>
        /// <param name="privacySettings"></param>
        /// <param name="jailbroken"></param>
        /// <param name="frida"></param>
        /// <param name="factoryReset"></param>
        /// <param name="clonedApp"></param>
        /// <param name="emulator"></param>
        /// <param name="rootApps"></param>
        /// <param name="vpnConfidence"></param>
        /// <param name="minSuspectScore"></param>
        /// <param name="developerTools"></param>
        /// <param name="locationSpoofing"></param>
        /// <param name="mitmAttack"></param>
        /// <param name="proxy"></param>
        /// <param name="sdkVersion"></param>
        /// <param name="sdkPlatform"></param>
        /// <param name="environment"></param>
        /// <param name="proximityId"></param>
        /// <param name="totalHits"></param>
        /// <param name="torNode"></param>
        partial void OnErrorSearchEvents(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> limit, Option<string> paginationKey, Option<string> visitorId, Option<BotFilter> bot, Option<string> ipAddress, Option<string> asn, Option<string> linkedId, Option<string> url, Option<string> origin, Option<long> start, Option<long> end, Option<bool> reverse, Option<bool> suspect, Option<bool> vpn, Option<bool> virtualMachine, Option<bool> tampering, Option<bool> antiDetectBrowser, Option<bool> incognito, Option<bool> privacySettings, Option<bool> jailbroken, Option<bool> frida, Option<bool> factoryReset, Option<bool> clonedApp, Option<bool> emulator, Option<bool> rootApps, Option<VpnConfidenceFilter> vpnConfidence, Option<float> minSuspectScore, Option<bool> developerTools, Option<bool> locationSpoofing, Option<bool> mitmAttack, Option<bool> proxy, Option<string> sdkVersion, Option<SdkPlatformFilter> sdkPlatform, Option<List<string>> environment, Option<string> proximityId, Option<long> totalHits, Option<bool> torNode);

        /// <summary>
        /// Search events ## Search  The &#x60;/v4/events&#x60; endpoint provides a convenient way to search for past events based on specific parameters. Typical use cases and queries include:  - Searching for events associated with a single &#x60;visitor_id&#x60; within a time range to get historical behavior of a visitor. - Searching for events associated with a single &#x60;linked_id&#x60; within a time range to get all events associated with your internal account identifier. - Excluding all bot traffic from the query (&#x60;good&#x60; and &#x60;bad&#x60; bots)  If you don&#39;t provide &#x60;start&#x60; or &#x60;end&#x60; parameters, the default search range is the **last 7 days**.  ### Filtering events with the &#x60;suspect&#x60; flag  The &#x60;/v4/events&#x60; endpoint unlocks a powerful method for fraud protection analytics. The &#x60;suspect&#x60; flag is exposed in all events where it was previously set by the update API.  You can also apply the &#x60;suspect&#x60; query parameter as a filter to find all potentially fraudulent activity that you previously marked as &#x60;suspect&#x60;. This helps identify patterns of fraudulent behavior.  ### Environment scoping  If you use a secret key that is scoped to an environment, you will only get events associated with the same environment. With a workspace-scoped environment, you will get events from all environments.  Smart Signals not activated for your workspace or are not included in the response. 
        /// </summary>
        /// <param name="request">The request parameters.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchEventsApiResponse"/>&gt;</returns>
        public async Task<ISearchEventsApiResponse> SearchEventsOrDefaultAsync(SearchEventsRequest request, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchEventsAsync(request, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search events
        /// </summary>
        /// <remarks>
        /// ## Search  The `/v4/events` endpoint provides a convenient way to search for past events based on specific parameters. Typical use cases and queries include:  - Searching for events associated with a single `visitor_id` within a time range to get historical behavior of a visitor. - Searching for events associated with a single `linked_id` within a time range to get all events associated with your internal account identifier. - Excluding all bot traffic from the query (`good` and `bad` bots)  If you don't provide `start` or `end` parameters, the default search range is the **last 7 days**.  ### Filtering events with the `suspect` flag  The `/v4/events` endpoint unlocks a powerful method for fraud protection analytics. The `suspect` flag is exposed in all events where it was previously set by the update API.  You can also apply the `suspect` query parameter as a filter to find all potentially fraudulent activity that you previously marked as `suspect`. This helps identify patterns of fraudulent behavior.  ### Environment scoping  If you use a secret key that is scoped to an environment, you will only get events associated with the same environment. With a workspace-scoped environment, you will get events from all environments.  Smart Signals not activated for your workspace or are not included in the response. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">The request parameters.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchEventsApiResponse"/>&gt;</returns>
        public async Task<ISearchEventsApiResponse> SearchEventsAsync(SearchEventsRequest request, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            // Extract parameters from request object
            Option<int> limit = request.Limit;
            Option<string> paginationKey = request.PaginationKey;
            Option<string> visitorId = request.VisitorId;
            Option<BotFilter> bot = request.Bot;
            Option<string> ipAddress = request.IpAddress;
            Option<string> asn = request.Asn;
            Option<string> linkedId = request.LinkedId;
            Option<string> url = request.Url;
            Option<string> origin = request.Origin;
            Option<long> start = request.Start;
            Option<long> end = request.End;
            Option<bool> reverse = request.Reverse;
            Option<bool> suspect = request.Suspect;
            Option<bool> vpn = request.Vpn;
            Option<bool> virtualMachine = request.VirtualMachine;
            Option<bool> tampering = request.Tampering;
            Option<bool> antiDetectBrowser = request.AntiDetectBrowser;
            Option<bool> incognito = request.Incognito;
            Option<bool> privacySettings = request.PrivacySettings;
            Option<bool> jailbroken = request.Jailbroken;
            Option<bool> frida = request.Frida;
            Option<bool> factoryReset = request.FactoryReset;
            Option<bool> clonedApp = request.ClonedApp;
            Option<bool> emulator = request.Emulator;
            Option<bool> rootApps = request.RootApps;
            Option<VpnConfidenceFilter> vpnConfidence = request.VpnConfidence;
            Option<float> minSuspectScore = request.MinSuspectScore;
            Option<bool> developerTools = request.DeveloperTools;
            Option<bool> locationSpoofing = request.LocationSpoofing;
            Option<bool> mitmAttack = request.MitmAttack;
            Option<bool> proxy = request.Proxy;
            Option<string> sdkVersion = request.SdkVersion;
            Option<SdkPlatformFilter> sdkPlatform = request.SdkPlatform;
            Option<List<string>> environment = request.Environment;
            Option<string> proximityId = request.ProximityId;
            Option<long> totalHits = request.TotalHits;
            Option<bool> torNode = request.TorNode;

            try
            {
                ValidateSearchEvents(paginationKey, visitorId, ipAddress, asn, linkedId, url, origin, sdkVersion, environment, proximityId);

                FormatSearchEvents(ref limit, ref paginationKey, ref visitorId, ref bot, ref ipAddress, ref asn, ref linkedId, ref url, ref origin, ref start, ref end, ref reverse, ref suspect, ref vpn, ref virtualMachine, ref tampering, ref antiDetectBrowser, ref incognito, ref privacySettings, ref jailbroken, ref frida, ref factoryReset, ref clonedApp, ref emulator, ref rootApps, ref vpnConfidence, ref minSuspectScore, ref developerTools, ref locationSpoofing, ref mitmAttack, ref proxy, ref sdkVersion, ref sdkPlatform, environment, ref proximityId, ref totalHits, ref torNode);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/events"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/events");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);
                    parseQueryStringLocalVar["ii"] = $"fingerprint-pro-server-api-dotnet-sdk/{ClientUtils.ClientVersion}";

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (paginationKey.IsSet)
                        parseQueryStringLocalVar["pagination_key"] = ClientUtils.ParameterToString(paginationKey.Value);

                    if (visitorId.IsSet)
                        parseQueryStringLocalVar["visitor_id"] = ClientUtils.ParameterToString(visitorId.Value);

                    if (bot.IsSet)
                        parseQueryStringLocalVar["bot"] = ClientUtils.ParameterToString(bot.Value);

                    if (ipAddress.IsSet)
                        parseQueryStringLocalVar["ip_address"] = ClientUtils.ParameterToString(ipAddress.Value);

                    if (asn.IsSet)
                        parseQueryStringLocalVar["asn"] = ClientUtils.ParameterToString(asn.Value);

                    if (linkedId.IsSet)
                        parseQueryStringLocalVar["linked_id"] = ClientUtils.ParameterToString(linkedId.Value);

                    if (url.IsSet)
                        parseQueryStringLocalVar["url"] = ClientUtils.ParameterToString(url.Value);

                    if (origin.IsSet)
                        parseQueryStringLocalVar["origin"] = ClientUtils.ParameterToString(origin.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (end.IsSet)
                        parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end.Value);

                    if (reverse.IsSet)
                        parseQueryStringLocalVar["reverse"] = ClientUtils.ParameterToString(reverse.Value);

                    if (suspect.IsSet)
                        parseQueryStringLocalVar["suspect"] = ClientUtils.ParameterToString(suspect.Value);

                    if (vpn.IsSet)
                        parseQueryStringLocalVar["vpn"] = ClientUtils.ParameterToString(vpn.Value);

                    if (virtualMachine.IsSet)
                        parseQueryStringLocalVar["virtual_machine"] = ClientUtils.ParameterToString(virtualMachine.Value);

                    if (tampering.IsSet)
                        parseQueryStringLocalVar["tampering"] = ClientUtils.ParameterToString(tampering.Value);

                    if (antiDetectBrowser.IsSet)
                        parseQueryStringLocalVar["anti_detect_browser"] = ClientUtils.ParameterToString(antiDetectBrowser.Value);

                    if (incognito.IsSet)
                        parseQueryStringLocalVar["incognito"] = ClientUtils.ParameterToString(incognito.Value);

                    if (privacySettings.IsSet)
                        parseQueryStringLocalVar["privacy_settings"] = ClientUtils.ParameterToString(privacySettings.Value);

                    if (jailbroken.IsSet)
                        parseQueryStringLocalVar["jailbroken"] = ClientUtils.ParameterToString(jailbroken.Value);

                    if (frida.IsSet)
                        parseQueryStringLocalVar["frida"] = ClientUtils.ParameterToString(frida.Value);

                    if (factoryReset.IsSet)
                        parseQueryStringLocalVar["factory_reset"] = ClientUtils.ParameterToString(factoryReset.Value);

                    if (clonedApp.IsSet)
                        parseQueryStringLocalVar["cloned_app"] = ClientUtils.ParameterToString(clonedApp.Value);

                    if (emulator.IsSet)
                        parseQueryStringLocalVar["emulator"] = ClientUtils.ParameterToString(emulator.Value);

                    if (rootApps.IsSet)
                        parseQueryStringLocalVar["root_apps"] = ClientUtils.ParameterToString(rootApps.Value);

                    if (vpnConfidence.IsSet)
                        parseQueryStringLocalVar["vpn_confidence"] = ClientUtils.ParameterToString(vpnConfidence.Value);

                    if (minSuspectScore.IsSet)
                        parseQueryStringLocalVar["min_suspect_score"] = ClientUtils.ParameterToString(minSuspectScore.Value);

                    if (developerTools.IsSet)
                        parseQueryStringLocalVar["developer_tools"] = ClientUtils.ParameterToString(developerTools.Value);

                    if (locationSpoofing.IsSet)
                        parseQueryStringLocalVar["location_spoofing"] = ClientUtils.ParameterToString(locationSpoofing.Value);

                    if (mitmAttack.IsSet)
                        parseQueryStringLocalVar["mitm_attack"] = ClientUtils.ParameterToString(mitmAttack.Value);

                    if (proxy.IsSet)
                        parseQueryStringLocalVar["proxy"] = ClientUtils.ParameterToString(proxy.Value);

                    if (sdkVersion.IsSet)
                        parseQueryStringLocalVar["sdk_version"] = ClientUtils.ParameterToString(sdkVersion.Value);

                    if (sdkPlatform.IsSet)
                        parseQueryStringLocalVar["sdk_platform"] = ClientUtils.ParameterToString(sdkPlatform.Value);

                    if (environment.IsSet)
                        parseQueryStringLocalVar["environment"] = ClientUtils.ParameterToString(environment.Value);

                    if (proximityId.IsSet)
                        parseQueryStringLocalVar["proximity_id"] = ClientUtils.ParameterToString(proximityId.Value);

                    if (totalHits.IsSet)
                        parseQueryStringLocalVar["total_hits"] = ClientUtils.ParameterToString(totalHits.Value);

                    if (torNode.IsSet)
                        parseQueryStringLocalVar["tor_node"] = ClientUtils.ParameterToString(torNode.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();
                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchEventsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchEventsApiResponse>();
                        SearchEventsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode)
                        {
                            default:
                                {
                                    string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);
                                    apiResponseLocalVar = new SearchEventsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/events", requestedAtLocalVar, _jsonSerializerOptions);

                                    break;
                                }
                        }

                        AfterSearchEventsDefaultImplementation(apiResponseLocalVar, limit, paginationKey, visitorId, bot, ipAddress, asn, linkedId, url, origin, start, end, reverse, suspect, vpn, virtualMachine, tampering, antiDetectBrowser, incognito, privacySettings, jailbroken, frida, factoryReset, clonedApp, emulator, rootApps, vpnConfidence, minSuspectScore, developerTools, locationSpoofing, mitmAttack, proxy, sdkVersion, sdkPlatform, environment, proximityId, totalHits, torNode);

                        Events.ExecuteOnSearchEvents(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode)429)
                            foreach (TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch (Exception e)
            {
                OnErrorSearchEventsDefaultImplementation(e, "/events", uriBuilderLocalVar.Path, limit, paginationKey, visitorId, bot, ipAddress, asn, linkedId, url, origin, start, end, reverse, suspect, vpn, virtualMachine, tampering, antiDetectBrowser, incognito, privacySettings, jailbroken, frida, factoryReset, clonedApp, emulator, rootApps, vpnConfidence, minSuspectScore, developerTools, locationSpoofing, mitmAttack, proxy, sdkVersion, sdkPlatform, environment, proximityId, totalHits, torNode);
                Events.ExecuteOnErrorSearchEvents(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchEventsApiResponse"/>
        /// </summary>
        public partial class SearchEventsApiResponse : Fingerprint.ServerSdk.Client.ApiResponse, ISearchEventsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchEventsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchEventsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchEventsApiResponse(ILogger<SearchEventsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchEventsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchEventsApiResponse(ILogger<SearchEventsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Fingerprint.ServerSdk.Model.EventSearch Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Fingerprint.ServerSdk.Model.EventSearch>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out Fingerprint.ServerSdk.Model.EventSearch result)
            {
                result = null;

                try
                {
                    result = Ok();
                }
                catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Fingerprint.ServerSdk.Model.ErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Fingerprint.ServerSdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest(out Fingerprint.ServerSdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                }
                catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public Fingerprint.ServerSdk.Model.ErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<Fingerprint.ServerSdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden(out Fingerprint.ServerSdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                }
                catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Fingerprint.ServerSdk.Model.ErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Fingerprint.ServerSdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError(out Fingerprint.ServerSdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                }
                catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateEvent(ref string eventId, EventUpdate eventUpdate);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="eventId"></param>
        /// <param name="eventUpdate"></param>
        /// <returns></returns>
        private void ValidateUpdateEvent(string eventId, EventUpdate eventUpdate)
        {
            if (eventId == null)
                throw new ArgumentNullException(nameof(eventId));

            if (eventUpdate == null)
                throw new ArgumentNullException(nameof(eventUpdate));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="eventId"></param>
        /// <param name="eventUpdate"></param>
        private void AfterUpdateEventDefaultImplementation(IUpdateEventApiResponse apiResponseLocalVar, string eventId, EventUpdate eventUpdate)
        {
            bool suppressDefaultLog = false;
            AfterUpdateEvent(ref suppressDefaultLog, apiResponseLocalVar, eventId, eventUpdate);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="eventId"></param>
        /// <param name="eventUpdate"></param>
        partial void AfterUpdateEvent(ref bool suppressDefaultLog, IUpdateEventApiResponse apiResponseLocalVar, string eventId, EventUpdate eventUpdate);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="eventId"></param>
        /// <param name="eventUpdate"></param>
        private void OnErrorUpdateEventDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string eventId, EventUpdate eventUpdate)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateEvent(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, eventId, eventUpdate);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="eventId"></param>
        /// <param name="eventUpdate"></param>
        partial void OnErrorUpdateEvent(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string eventId, EventUpdate eventUpdate);

        /// <summary>
        /// Update an event Change information in existing events specified by &#x60;event_id&#x60; or *flag suspicious events*.  When an event is created, it can be assigned &#x60;linked_id&#x60; and &#x60;tags&#x60; submitted through the JS agent parameters.  This information might not have been available on the client initially, so the Server API permits updating these attributes after the fact.  **Warning** It&#39;s not possible to update events older than one month.   **Warning** Trying to update an event immediately after creation may temporarily result in an  error (HTTP 409 Conflict. The event is not mutable yet.) as the event is fully propagated across our systems. In such a case, simply retry the request. 
        /// </summary>
        /// <param name="eventId">The unique event [identifier](https://dev.fingerprint.com/reference/get-function#event_id).</param>
        /// <param name="eventUpdate"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateEventApiResponse"/>&gt;</returns>
        public async Task<IUpdateEventApiResponse> UpdateEventOrDefaultAsync(string eventId, EventUpdate eventUpdate, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateEventAsync(eventId, eventUpdate, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update an event
        /// </summary>
        /// <remarks>
        /// Change information in existing events specified by `event_id` or *flag suspicious events*.  When an event is created, it can be assigned `linked_id` and `tags` submitted through the JS agent parameters.  This information might not have been available on the client initially, so the Server API permits updating these attributes after the fact.  **Warning** It's not possible to update events older than one month.   **Warning** Trying to update an event immediately after creation may temporarily result in an  error (HTTP 409 Conflict. The event is not mutable yet.) as the event is fully propagated across our systems. In such a case, simply retry the request. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The unique event [identifier](https://dev.fingerprint.com/reference/get-function#event_id).</param>
        /// <param name="eventUpdate"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateEventApiResponse"/>&gt;</returns>
        public async Task<IUpdateEventApiResponse> UpdateEventAsync(string eventId, EventUpdate eventUpdate, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateEvent(eventId, eventUpdate);

                FormatUpdateEvent(ref eventId, eventUpdate);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/events/{event_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/events/{event_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bevent_id%7D", Uri.EscapeDataString(eventId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);
                    parseQueryStringLocalVar["ii"] = $"fingerprint-pro-server-api-dotnet-sdk/{ClientUtils.ClientVersion}";

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();
                    httpRequestMessageLocalVar.Content = (eventUpdate as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(eventUpdate, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("PATCH");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UpdateEventApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateEventApiResponse>();
                        UpdateEventApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode)
                        {
                            default:
                                {
                                    string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);
                                    apiResponseLocalVar = new UpdateEventApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/events/{event_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                    break;
                                }
                        }

                        AfterUpdateEventDefaultImplementation(apiResponseLocalVar, eventId, eventUpdate);

                        Events.ExecuteOnUpdateEvent(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode)429)
                            foreach (TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch (Exception e)
            {
                OnErrorUpdateEventDefaultImplementation(e, "/events/{event_id}", uriBuilderLocalVar.Path, eventId, eventUpdate);
                Events.ExecuteOnErrorUpdateEvent(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateEventApiResponse"/>
        /// </summary>
        public partial class UpdateEventApiResponse : Fingerprint.ServerSdk.Client.ApiResponse, IUpdateEventApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateEventApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateEventApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateEventApiResponse(ILogger<UpdateEventApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UpdateEventApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateEventApiResponse(ILogger<UpdateEventApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Fingerprint.ServerSdk.Model.ErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Fingerprint.ServerSdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest(out Fingerprint.ServerSdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                }
                catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public Fingerprint.ServerSdk.Model.ErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<Fingerprint.ServerSdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden(out Fingerprint.ServerSdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                }
                catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Fingerprint.ServerSdk.Model.ErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Fingerprint.ServerSdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound(out Fingerprint.ServerSdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                }
                catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public Fingerprint.ServerSdk.Model.ErrorResponse Conflict()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsConflict
                    ? System.Text.Json.JsonSerializer.Deserialize<Fingerprint.ServerSdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryConflict(out Fingerprint.ServerSdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = Conflict();
                }
                catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)409);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
