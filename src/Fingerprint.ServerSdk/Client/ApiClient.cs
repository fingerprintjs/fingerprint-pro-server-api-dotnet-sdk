/*
 * Fingerprint Server API
 *
 * Fingerprint Server API allows you to search, update, and delete identification events in a server environment. It can be used for data exports, decision-making, and data analysis scenarios. Server API is intended for server-side usage, it's not intended to be used from the client side, whether it's a browser or a mobile device.
 *
 * OpenAPI spec version: 3
 * Contact: support@fingerprint.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System.Net;
using System.Net.Http;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Web;
using Fingerprint.ServerSdk.Api;
using Fingerprint.ServerSdk.Json;
using Fingerprint.ServerSdk.Model;

namespace Fingerprint.ServerSdk.Client
{
    /// <summary>
    /// API client is responsible for making the HTTP call to the API backend.
    /// </summary>
    public class ApiClient
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiClient" /> class
        /// with default base path (https://api.fpjs.io).
        /// </summary>
        /// <param name="config">An instance of Configuration.</param>
        public ApiClient(Configuration config)
        {
            Configuration = config;

            Client = config.HttpClient ?? new HttpClient()
            {
                BaseAddress = new Uri(Configuration.BasePath),
                Timeout = TimeSpan.FromMilliseconds(Configuration.Timeout)
            };
        }

        /// <summary>
        /// Gets or sets the HttpClient.
        /// </summary>
        /// <value>An instance of the HttpClient</value>
        public HttpClient Client { get; set; }

        /// <summary>
        /// Gets or sets an instance of the IReadableConfiguration.
        /// </summary>
        /// <value>An instance of the IReadableConfiguration.</value>
        /// <remarks>
        /// <see cref="IReadableConfiguration"/> helps us to avoid modifying possibly global
        /// configuration values from within a given client. It does not guarantee thread-safety
        /// of the <see cref="Configuration"/> instance in any way.
        /// </remarks>
        public IReadableConfiguration Configuration { get; set; }

        private HttpRequestMessage CreateRequestMessage(HttpMethod method, UriBuilder uri,
            List<KeyValuePair<string, string>>? queryParams, HttpContent? body = null)
        {
            var query = HttpUtility.ParseQueryString(uri.Query);
            query["ii"] = $"fingerprint-pro-server-api-dotnet-sdk/{ServerSdk.Client.Configuration.Version}";
            if (queryParams != null)
            {
                foreach (var param in queryParams)
                {
                    query.Add(param.Key, param.Value);
                }
            }

            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                query["api_key"] = this.Configuration.GetApiKeyWithPrefix("api_key");
            }

            uri.Query = query.ToString();

            var request = new HttpRequestMessage(method, uri.ToString());
            request.Content = body;
            request.Headers.TryAddWithoutValidation("User-Agent", Configuration.UserAgent);
            var apiKey = Configuration.GetApiKeyWithPrefix("Auth-API-Key");
            if (!string.IsNullOrEmpty(apiKey))
            {
                request.Headers.TryAddWithoutValidation("Auth-API-Key", apiKey);
            }

            foreach (var header in Configuration.DefaultHeader)
            {
                request.Headers.TryAddWithoutValidation(header.Key, header.Value);
            }

            return request;
        }

        private UriBuilder GetRequestPath(OperationDefinition definition, params string[]? args)
        {
            var uriBuilder = new UriBuilder(Client.BaseAddress?.ToString() ?? Configuration.BasePath)
            {
                Path = definition.GetPath(args)
            };

            return uriBuilder;
        }

        public async Task<ApiResponse<object>> DoRequestEmpty(ApiRequest apiRequest)
        {
            var definition = apiRequest.OperationDefinition;

            var path = GetRequestPath(definition, apiRequest.Args);
            var request = CreateRequestMessage(apiRequest.Method, path, apiRequest.QueryParams, apiRequest.Body);

            var response = await Client.SendAsync(request);
            var responseContent = await response.Content.ReadAsStringAsync();

            if (!response.IsSuccessStatusCode)
                HandleException(definition.OperationName, response, responseContent, definition);

            return new ApiResponse<object>(response, null!);
        }

        public async Task<ApiResponse<T>> DoRequest<T>(ApiRequest apiRequest)
        {
            var definition = apiRequest.OperationDefinition;

            var path = GetRequestPath(definition, apiRequest.Args);
            var request = CreateRequestMessage(apiRequest.Method, path, apiRequest.QueryParams, apiRequest.Body);

            var response = await Client.SendAsync(request);
            var responseContent = await response.Content.ReadAsStringAsync();

            if (!response.IsSuccessStatusCode)
                HandleException(definition.OperationName, response, responseContent, definition);

            T? data;

            try
            {
                data = JsonUtils.Deserialize<T>(responseContent);
            }
            catch (Exception e)
            {
                throw new JsonDeserializeException(response, e);
            }

            return new ApiResponse<T>(response, data!);
        }

        private void HandleException(string methodName, HttpResponseMessage response, string responseContent,
            OperationDefinition operationDefinition)
        {
            var message = $"Error calling {methodName}: {response.ReasonPhrase}";
            var statusCode = (int)response.StatusCode;
            var errorCode = ErrorCode.Failed;

            if (!operationDefinition.ResponseStatusCodeMap.TryGetValue(statusCode, out var model))
                throw new ApiException(statusCode,
                    message, errorCode, response);


            var result = JsonUtils.Deserialize(responseContent, model);

            switch (result)
            {
                case ErrorResponse errorResponse:
                    message = errorResponse.Error.Message;
                    errorCode = errorResponse.Error.Code;
                    break;
                case ErrorPlainResponse errorPlainResponse:
                    message = errorPlainResponse.Error;
                    break;
            }

            // https://github.com/dotnet/runtime/issues/54321
            if (response.StatusCode != (HttpStatusCode)429)
                throw new ApiException(statusCode, message, errorCode, response, result);


            var retryAfterHeader = response.Headers.FirstOrDefault(h => h.Key == "Retry-After").Value
                ?.FirstOrDefault();
            int? retryAfterInt = !string.IsNullOrEmpty(retryAfterHeader) ? int.Parse(retryAfterHeader) : null;

            throw new TooManyRequestsException(message, response, retryAfterInt);
        }
    }
}
