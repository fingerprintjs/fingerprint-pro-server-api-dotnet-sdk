// <auto-generated>
/* 
 * Fingerprint Server API
 *
 * Fingerprint Server API allows you to search, update, and delete identification events in a server environment. It can be used for data exports, decision-making, and data analysis scenarios. Server API is intended for server-side usage, it's not intended to be used from the client side, whether it's a browser or a mobile device. 
 *
 * The version of the OpenAPI document: 4
 * Contact: support@fingerprint.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Fingerprint.ServerSdk.Client;

namespace Fingerprint.ServerSdk.Model
{
    /// <summary>
    /// Bounding box metrics describing how the emoji glyph renders.
    /// </summary>
    public partial class Emoji : IValidatableObject
    {


        /// <summary>
        /// Initializes a new instance of the <see cref="Emoji" /> class.
        /// </summary>
        /// <param name="font">Font family reported by the browser when drawing the emoji..</param>
        /// <param name="width">width.</param>
        /// <param name="height">height.</param>
        /// <param name="top">top.</param>
        /// <param name="bottom">bottom.</param>
        /// <param name="left">left.</param>
        /// <param name="right">right.</param>
        /// <param name="x">x.</param>
        /// <param name="y">y.</param>
        [JsonConstructor]
        public Emoji(Option<string> font = default, Option<double?> width = default, Option<double?> height = default, Option<double?> top = default, Option<double?> bottom = default, Option<double?> left = default, Option<double?> right = default, Option<double?> x = default, Option<double?> y = default)
        {
            FontOption = font;
            WidthOption = width;
            HeightOption = height;
            TopOption = top;
            BottomOption = bottom;
            LeftOption = left;
            RightOption = right;
            XOption = x;
            YOption = y;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Used to track the state of Font
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> FontOption { get; private set; }

        /// <summary>
        /// Font family reported by the browser when drawing the emoji.
        /// </summary>
        /// <value>Font family reported by the browser when drawing the emoji.</value>
        [JsonPropertyName("font")]
        public string Font { get { return this.FontOption; } set { this.FontOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of Width
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<double?> WidthOption { get; private set; }

        /// <summary>
        /// Gets or Sets Width
        /// </summary>
        [JsonPropertyName("width")]
        public double? Width { get { return this.WidthOption; } set { this.WidthOption = new Option<double?>(value); } }

        /// <summary>
        /// Used to track the state of Height
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<double?> HeightOption { get; private set; }

        /// <summary>
        /// Gets or Sets Height
        /// </summary>
        [JsonPropertyName("height")]
        public double? Height { get { return this.HeightOption; } set { this.HeightOption = new Option<double?>(value); } }

        /// <summary>
        /// Used to track the state of Top
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<double?> TopOption { get; private set; }

        /// <summary>
        /// Gets or Sets Top
        /// </summary>
        [JsonPropertyName("top")]
        public double? Top { get { return this.TopOption; } set { this.TopOption = new Option<double?>(value); } }

        /// <summary>
        /// Used to track the state of Bottom
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<double?> BottomOption { get; private set; }

        /// <summary>
        /// Gets or Sets Bottom
        /// </summary>
        [JsonPropertyName("bottom")]
        public double? Bottom { get { return this.BottomOption; } set { this.BottomOption = new Option<double?>(value); } }

        /// <summary>
        /// Used to track the state of Left
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<double?> LeftOption { get; private set; }

        /// <summary>
        /// Gets or Sets Left
        /// </summary>
        [JsonPropertyName("left")]
        public double? Left { get { return this.LeftOption; } set { this.LeftOption = new Option<double?>(value); } }

        /// <summary>
        /// Used to track the state of Right
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<double?> RightOption { get; private set; }

        /// <summary>
        /// Gets or Sets Right
        /// </summary>
        [JsonPropertyName("right")]
        public double? Right { get { return this.RightOption; } set { this.RightOption = new Option<double?>(value); } }

        /// <summary>
        /// Used to track the state of X
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<double?> XOption { get; private set; }

        /// <summary>
        /// Gets or Sets X
        /// </summary>
        [JsonPropertyName("x")]
        public double? X { get { return this.XOption; } set { this.XOption = new Option<double?>(value); } }

        /// <summary>
        /// Used to track the state of Y
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<double?> YOption { get; private set; }

        /// <summary>
        /// Gets or Sets Y
        /// </summary>
        [JsonPropertyName("y")]
        public double? Y { get { return this.YOption; } set { this.YOption = new Option<double?>(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class Emoji {\n");
            sb.Append("  Font: ").Append(Font).Append("\n");
            sb.Append("  Width: ").Append(Width).Append("\n");
            sb.Append("  Height: ").Append(Height).Append("\n");
            sb.Append("  Top: ").Append(Top).Append("\n");
            sb.Append("  Bottom: ").Append(Bottom).Append("\n");
            sb.Append("  Left: ").Append(Left).Append("\n");
            sb.Append("  Right: ").Append(Right).Append("\n");
            sb.Append("  X: ").Append(X).Append("\n");
            sb.Append("  Y: ").Append(Y).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="Emoji" />
    /// </summary>
    public class EmojiJsonConverter : JsonConverter<Emoji>
    {
        /// <summary>
        /// Deserializes json to <see cref="Emoji" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override Emoji Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string> font = default;
            Option<double?> width = default;
            Option<double?> height = default;
            Option<double?> top = default;
            Option<double?> bottom = default;
            Option<double?> left = default;
            Option<double?> right = default;
            Option<double?> x = default;
            Option<double?> y = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "font":
                            font = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "width":
                            width = new Option<double?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (double?)null : utf8JsonReader.GetDouble());
                            break;
                        case "height":
                            height = new Option<double?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (double?)null : utf8JsonReader.GetDouble());
                            break;
                        case "top":
                            top = new Option<double?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (double?)null : utf8JsonReader.GetDouble());
                            break;
                        case "bottom":
                            bottom = new Option<double?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (double?)null : utf8JsonReader.GetDouble());
                            break;
                        case "left":
                            left = new Option<double?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (double?)null : utf8JsonReader.GetDouble());
                            break;
                        case "right":
                            right = new Option<double?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (double?)null : utf8JsonReader.GetDouble());
                            break;
                        case "x":
                            x = new Option<double?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (double?)null : utf8JsonReader.GetDouble());
                            break;
                        case "y":
                            y = new Option<double?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (double?)null : utf8JsonReader.GetDouble());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (font.IsSet && font.Value == null)
                throw new ArgumentNullException(nameof(font), "Property is not nullable for class Emoji.");

            if (width.IsSet && width.Value == null)
                throw new ArgumentNullException(nameof(width), "Property is not nullable for class Emoji.");

            if (height.IsSet && height.Value == null)
                throw new ArgumentNullException(nameof(height), "Property is not nullable for class Emoji.");

            if (top.IsSet && top.Value == null)
                throw new ArgumentNullException(nameof(top), "Property is not nullable for class Emoji.");

            if (bottom.IsSet && bottom.Value == null)
                throw new ArgumentNullException(nameof(bottom), "Property is not nullable for class Emoji.");

            if (left.IsSet && left.Value == null)
                throw new ArgumentNullException(nameof(left), "Property is not nullable for class Emoji.");

            if (right.IsSet && right.Value == null)
                throw new ArgumentNullException(nameof(right), "Property is not nullable for class Emoji.");

            if (x.IsSet && x.Value == null)
                throw new ArgumentNullException(nameof(x), "Property is not nullable for class Emoji.");

            if (y.IsSet && y.Value == null)
                throw new ArgumentNullException(nameof(y), "Property is not nullable for class Emoji.");

            return new Emoji(font, width, height, top, bottom, left, right, x, y);
        }

        /// <summary>
        /// Serializes a <see cref="Emoji" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="emoji"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, Emoji emoji, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, emoji, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="Emoji" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="emoji"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, Emoji emoji, JsonSerializerOptions jsonSerializerOptions)
        {
            if (emoji.FontOption.IsSet && emoji.Font == null)
                throw new ArgumentNullException(nameof(emoji.Font), "Property is required for class Emoji.");

            if (emoji.FontOption.IsSet)
                writer.WriteString("font", emoji.Font);

            if (emoji.WidthOption.IsSet)
                writer.WriteNumber("width", emoji.WidthOption.Value.Value);

            if (emoji.HeightOption.IsSet)
                writer.WriteNumber("height", emoji.HeightOption.Value.Value);

            if (emoji.TopOption.IsSet)
                writer.WriteNumber("top", emoji.TopOption.Value.Value);

            if (emoji.BottomOption.IsSet)
                writer.WriteNumber("bottom", emoji.BottomOption.Value.Value);

            if (emoji.LeftOption.IsSet)
                writer.WriteNumber("left", emoji.LeftOption.Value.Value);

            if (emoji.RightOption.IsSet)
                writer.WriteNumber("right", emoji.RightOption.Value.Value);

            if (emoji.XOption.IsSet)
                writer.WriteNumber("x", emoji.XOption.Value.Value);

            if (emoji.YOption.IsSet)
                writer.WriteNumber("y", emoji.YOption.Value.Value);
        }
    }
}
